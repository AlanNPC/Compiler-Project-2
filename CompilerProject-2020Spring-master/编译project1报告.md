#### 编译project1报告

**小组编号: 10**
**小组成员：贺义鸣 沈若冰 姜欣睿 徐逸飞**

**一、设计思路**

​	本次project需要根据给定的生成规则生成实现对应功能的c\c++源代码。在设计思路上，第一步，需要解析输入的json文件获取生成规则。第二步，根据生成规则，利用输入的表达式文法，用IR节点构建语法树，作为输入表达式的中间表示。第三步，根据得到的语法树，利用IR Visitor，访问语法树，在不同节点作不同的输出，最终合并输出得到目标的c\c++源代码。
​	具体而言，每一步的实现思路如下：
​	第一步，对json的解析较为简单，只需调用json解析库即可。
​	第二步，这一步主要的工作在于构建语法树，对于面临的问题，我们设计的解决思路主要有以下几点：
a、由于输入表达式中的空格容易影响对变量名称的解析，因此首先我们过滤掉了所有的空格，并且对于每一个";"分割的语句都分别处理。
b、对于每一条语句，由于下标index的位置影响语义，例如在输出张量中不出现的index代表一个循环，不同”项“中index循环不能嵌套，每个index有自己的范围等。因此在对每一条语句的处理中，我们首先扫描语句，区分出位于输出中的index和在输出中不出现的index，此外，对每个单独出现的index，根据其多次出现中数组的维度，可以得到该index取值的一个尽量小的范围，我们根据这个范围建立并记录了每个index的名称到对应树节点的映射。
c、由于b中获得的index范围依然是不够精确的，例如出现i+j等下标组合的表达式时，难以推断出i和j各自的范围。为了保证在对张量的访问中下标不会越界，我们对所有的张量访问都添加了if判断来保证安全性。建立完下标名称到树节点的映射后，我们重新扫描语句，把对每一个张量访问需要的约束都记录下来，例如根据$A<range>[IdExpr]$，我们会得到$IdExpr<range$的约束，这些代表约束的树节点被预先统计并存储。
d、利用输出表达式中出现的下标可以构建外部循环。例如输出为$A[i][j]$，说明外部循环应当是i和j嵌套的双重循环。外侧循环内部的子循环由在输出表达式中不出现的下标决定。但是由于不同项之间的循环不应该嵌套，例如$B<5>[k]+C<5>[j]$,$j$和$k$的循环不应该嵌套。因此我们进一步用“+“和“-”分割得到不同的项，并对每一个项单独构建子循环。
e、对每个项的处理构建子循环的主要过程是根据文法解析表达式。需要注意不同符号的优先级，将表达式解析成语法树的过程中，存储张量名称到对应树节点的映射。此外对每个项解析得到的语法树，我们都根据c中得到的约束节点构建if节点包装表达式，来保证对张量的安全访问。在选择约束节点时，需要注意，约束节点只能包含该项中出现的下标变量。
f、为了保证在类似$A[i][j]=A[j][i]$这样的情况中能正确完成转置，我们利用临时数组记录结果，在外侧循环的最后才将计算结果存储进输出数组中。
​	第三步，这一步的工作主要在于修改IR Visitor，在访问不同的节点时有不同的输出，并使得输出字符能拼接成c\c++程序。实现思路较为简单，例如在访问循环节点的时候输出“for”等，保证得到正确语法的c程序即可。

**二、实现方法**

​	在这一部分，我们更为具体的呈现了每一步的实现。
​	第一步，我们使用了boost 提供的property_tree 作为工具来解析Json，用于获得待生成函数名name，输入变量列表ins，输出变量列表outs，数据类型data_type以及用表达式给出的待生成函数kernel。这一步的代码主要位于类 Json_Parser中。
​	第二步，这一步我们编写了类Parser来实现设计思路，其核心的函数及功能如下：
*1、方法Parser::parse：*
​	是语法树解析的核心函数，通过调用其他函数完成语法树解析。输入为第一步json解析得到的结果，解析得到完整的语法树后，将根节点记录在类属性Parser::kernel中。该函数主要执行了以下工作：过滤输入表达式中的空格，将输入表达式用";"分隔得到不同的语句；调用Parser::processOne函数对每条语句单独处理，获得函数体节点；将输入输出张量名去重，并利用在processOne函数处理过程中记录在Parser::varMP中输入输出张量名和语法树节点的对应关系，组合输入输出节点以及函数体节点，得到最终的语法树根节点。
*2、方法Parser::processOne：*
​	用于处理以“；“结束的一条语句，输入语句的表达式，返回该语句解析得到子树的根节点。该函数首先调用 Parser::registerIndex扫描整条语句，统计了每个index的最小范围，区分了在输出张量中的index和在输出张量中不出现的index，并建立index的名称和对应树节点的映射，其中在输出张量中的index的映射记录在属性Parser::leftIndex中，在输出张量中不出现的index记录在属性Parser::rightIndex中。而后，通过调用Parser::buildConstriction函数，统计所有访问张量时下标表达式的范围约束。最后，该函数对每一个用”+“和”-“分割的项，调用Parser::build_loop函数构建子循环，并利用在输出中出现的下标在子循环外构建外部循环并返回子树的根节点。
*3、方法Parser::build_loop:*
​	该函数用于根据“项”来建立每一个子循环。首先，通过调用$Parser::AddSub$,$Parser::Mod$,$Parser::MulDiv$和$Parser::operand$解析表达式，不同的函数对应运算符号的不同优先级，我们认为优先级$*,/,//>\% >+,-$。在解析的过程中，我们建立张量名称到对应树节点的映射，记录在Parser::varMP中，并统计该项中不出现在输出张量中的下标，用于构建子循环。此外，我们用if节点包装了循环体，用于保证张量访问下标不会越界。循环体的条件中包含用&&连接的约束节点，若一个约束节点包含了不在该项中出现的下标变量，则该约束节点被过滤。对于临时数组的使用，我们在每个子循环中利用tmp数组累计每个项的结果，在子循环之间利用ret数组累计tmp数组的值，在外侧循环的最后将ret数组的值赋给输出数组。
​	第三步，我们修改了类IRPrinter的实现，使其在不同节点输出符合c\c++语法的字符。此外，由于使用了临时数组，我们在函数的开始根据data_type和输出数组的维度，额外输出了对临时数组的定义语句。

**三、组内分工**

由贺义鸣、沈若冰负责project1，由姜欣睿、徐逸飞负责project2